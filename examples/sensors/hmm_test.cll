// -*- c -*-
module Hmm() {

  fix9_t@{[0:14]=1} quantizerMap_x[14];
  fix9_t@{[0:14]=2} quantizerMap_y[14];
  fix9_t@{[0:14]=3} quantizerMap_z[14];

  fix1_t@7 b1[28]; // 2x14
  fix1_t@5 b2[42]; // 3x14
  fix1_t@6 b3[42]; // 3x14

  fix1_t@17 a1[24];
  fix1_t@22 a2[40];

  fix1_t@14 pi[8];
  fix1_t@15 f[8];
  fix1_t@15 s[8]; //fix1_t@20 s[8];
  int@18 started;

  int derive_group(fix9_t::3@(4,4,4) acc){
    fix9_t@1 x;
    fix9_t@2 y;
    fix9_t@3 z;
    x = acc::0;
    y = acc::1;
    z = acc::2;

    fix9_t@0 minDist; minDist = 255;//0b11111111;
    int@0 minGroup;
    int@4 ret;

    fix9_t@0 dx;
    fix9_t@0 dy;
    fix9_t@0 dz;
    fix9_t@0 d;

    for (i from 0 to 14){

      dx = (quantizerMap_x[i] -@1 x) *@1 (quantizerMap_x[i] -@1 x);
      dy = (quantizerMap_y[i] -@2 y) *@2 (quantizerMap_y[i] -@2 y);
      dz = (quantizerMap_z[i] -@3 z) *@3 (quantizerMap_z[i] -@3 z);

      d = dx +@0 dy +@0 dz;
      if (d <@0 minDist){
        minDist = d;
        minGroup = i;
      }
    }
    ret = minGroup;
    return ret;
  }

  actor* get_b3;
  fix1_t@5 get_b3(int@6 i) {
    return b3[i -@6 70];
  }

  actor* get_b2;
  fix1_t@7 get_b2(int@5 i) {
    fix1_t@5 ret;
    if(i <@5 70) {
      ret = b2[i -@5 28];
    } else {
      ret = get_b3(i);
    }
    return ret;
  }

  actor* get_b;
  fix1_t get_b(int@7 i) {
    fix1_t@7 ret;
    if(i <@7 28) {
      ret = b1[i];
    } else {
      ret = get_b2(i);
    }
    return ret;
  }

  //   actor* get_a2;
  //   fix1_t@17 get_a2(int@22 i) {
  //     return a2[i -@22 28];
  //   }
  // 
  //   actor* get_a;
  //   fix1_t get_a(int@17 i) {
  //     fix1_t@17 ret;
  //     if(i <@17 28) {
  //       ret = a1[i];
  //     } else {
  //       ret = get_a2(i);
  //     }
  //     return ret;
  //   }


//  actor* get_s__;
//  fix1_t@20 get_s__(int@20 i){
//    return s[i];
//  }
//  fix1_t@21 get_s(int@21 i){
//    return get_s__(i);
//  }
//
//  actor* set_s__;
//  void set_s__(int@20 i, fix1_t@20 x){
//    s[i] = x;
//  }
//  void set_s(int@21 i, fix1_t@21 x){
//    set_s__(i, x);
//  }
//
//  actor* get_t__;
//  fix1_t@15 get_t__(int@15 i){
//    return s[i];
//  }
//
//  fix1_t@21 get_t(int@21 i){
//    return get_t__(i);
//  }
//
//  actor* set_t__;
//  void set_t__(int@15 i, fix1_t@15 x){
//    s[i] = x;
//  }
//  void set_t(int@21 i, fix1_t@21 x){
//    set_t__(i, x);
//  }
  

  actor* forward_proc_inc;
  int forward_proc_inc(int@8 o){
    fix1_t@8 sum;
    fix1_t@8 ord;
    fix1_t@8 temp;
    ord = 0;
    if(started == 1) {
      sum = 0;
      for (k from 0 to 8) {
        temp = sum *@8 get_b(k *@8 14 +@8 o);
        //f[k] = temp;
        //for (l from 0 to 8){
        //sum = sum + get_a((3 <<@8 3) +@8 k);
        //sum = get_a((3 <<@8 3) +@8 k);
        //sum = a1[(3 <<@8 3) +@8 k];
        sum = 2;
          //}
        ///ord = ord | temp;
      }
    }else{
      started = 1;
      for (k from 0 to 8) {
        temp = sum *@8 get_b(k *@8 14 +@8 o);
      }
    }
    return ord;
  }

  fix1_t forward_proc_out() {
    fix1_t@19 prob;
    prob = 0;
    started = 0;
    for (i from 0 to 8){
      prob = prob +@19 s[i];
    }
    return prob;
  }

  //actor* shift_s;
  //void shift_s(int n){
    //  for (i from 0 to 8){
      //    set_s(i, get_s(i) <<@17 n);
      //  }
    //}

  //  actor* input;
  // ==>
  // uncaught exception: "visitor-regalloc: there should be only one item on stock for assignment"
  int input(fix9_t::3@(9,9,9) acc){
    int@9 ord;
    ord = forward_proc_inc(derive_group(acc));
    return ord;
  }

} // end module Hmm

//hmm1 = new Hmm()@REG(1,404);
//hmm2 = new Hmm()@REG(106,409);
hmm1 = new Hmm()@REG(102,506);
hmm2 = new Hmm()@REG(107,511);
//hmm1 = new Hmm();
//hmm2 = new Hmm();


//int filter(fix9_t::3 acc){
//  fix9_t@10 abs;
//  abs = acc::0 *@10 acc::0 +@10 acc::1 *@10 acc::1 +@10 acc::2 *@10 acc::2;
//
//  return abs;
//}

//fix9_t::3@(12,12,12) dir_filter_ref;
fix9_t@12 filter_ref_x;
fix9_t@12 filter_ref_y;
fix9_t@12 filter_ref_z;

int filter(fix9_t@11 x_in, fix9_t@11 y_in, fix9_t@11 z_in){

  // node 5
  fix9_t@10 abs;
  abs = x_in *@11 x_in +@11 y_in *@11 y_in +@11 z_in *@11 z_in;

  // node 6
  int@10 ret2;
  fix9_t@10 x;
  fix9_t@10 y;
  fix9_t@10 z;
  x = x_in;
  y = y_in;
  z = z_in;

  ret2 = 0;
  if (abs >@10 1.1){
    ret2 = 1;
  }
  if (abs <@10 0.9){
    ret2 = 1;
  }

  // node @12
  int@12 ret;
  ret = ret2;
  //fix9_t idle_sensitivity = 0.1;//0.3;

  //fix9_t@12 def_sensitivity;
  //def_sensitivity = 0.4;//0.5;

  if (ret){
    ret = 0;
    if (x <@12 filter_ref_x -@12 0.4){
      ret = 1;
    }
    if (x >@12 filter_ref_x +@12 0.4){
      ret = 1;
    }
    if (y <@12 filter_ref_y -@12 0.4){
      ret = 1;
    }
    if (y >@12 filter_ref_y +@12 0.4){
      ret = 1;
    }
    if (z <@12 filter_ref_z -@12 0.4){
      ret = 1;
    }
    if (z >@12 filter_ref_z +@12 0.4){
      ret = 1;
    }
  }

  // node 6
  ret2 = ret;
  if (ret2){
    filter_ref_x = x;
    filter_ref_y = y;
    filter_ref_z = z;
  }

  return ret;
}


void main(){
  fix9_t::3@(13,13,13) acc;
  int@13 ord;
  int@16 n;
  if (filter(acc::0, acc::1, acc::2)){
    ord = ord |@13 hmm1.input(acc);
    ord = ord |@13 hmm2.input(acc);
    n = 0;
    while (ord >@16 0){
      n = n +@16 1;
      ord = ord <<@16 1;
    }
    if (n >@16 3){
      n = n -@16 3;
      //hmm1.shift_s(n);
      //hmm2.shift_s(n);
    }
  }
  fix1_t@13 out1;
  fix1_t@13 out2;

  out1 = hmm1.forward_proc_out();
  out2 = hmm2.forward_proc_out();
}
